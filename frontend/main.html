<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel de Agente - Llamadas de WhatsApp</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background-color: #f0f2f5; color: #1c1e21; }
        .container { background-color: #fff; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); text-align: center; width: 90%; max-width: 400px; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        #status { font-size: 1rem; margin-bottom: 1.5rem; padding: 0.5rem; border-radius: 4px; }
        .status-connecting { color: #f5a623; background-color: #fffbe6; }
        .status-connected { color: #2e7d32; background-color: #e8f5e9; }
        .status-disconnected { color: #d32f2f; background-color: #ffebee; }
        .call-controls button { padding: 0.8rem 1.5rem; font-size: 1rem; border: none; border-radius: 6px; cursor: pointer; margin: 0 0.5rem; transition: background-color 0.2s; }
        .answer-btn { background-color: #42b72a; color: white; }
        .answer-btn:hover { background-color: #36a420; }
        .hangup-btn { background-color: #fa383e; color: white; }
        .hangup-btn:hover { background-color: #e02c32; }
        #incoming-call-alert, #in-call-view { display: none; }
        #caller-info { font-weight: bold; margin-bottom: 1rem; }
        audio { margin-top: 1rem; width: 100%; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Panel de Llamadas</h1>
        <p id="status" class="status-connecting">Estado: Conectando al servidor...</p>
        <div id="incoming-call-alert">
            <p id="caller-info">Llamada entrante...</p>
            <div class="call-controls">
                <button id="answer-button" class="answer-btn">Contestar</button>
            </div>
        </div>
        <div id="in-call-view">
            <p>Llamada en curso...</p>
            <audio id="remote-audio" autoplay playsinline></audio>
            <div class="call-controls">
                <button id="hangup-button" class="hangup-btn">Colgar</button>
            </div>
        </div>
    </div>

    <script>
        let ws;
        let browser_pc;
        let localStream;
        let currentCallId = null;

        const statusEl = document.getElementById('status');
        const incomingCallAlertEl = document.getElementById('incoming-call-alert');
        const inCallViewEl = document.getElementById('in-call-view');
        const callerInfoEl = document.getElementById('caller-info');
        const answerButton = document.getElementById('answer-button');
        const hangupButton = document.getElementById('hangup-button');
        const remoteAudioEl = document.getElementById('remote-audio');

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            const wsUrl = `${protocol}//${host}/ws`;

            console.log(`Conectando al lobby en: ${wsUrl}`);
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log("Conectado al lobby de llamadas.");
                statusEl.textContent = 'Estado: Listo para recibir llamadas';
                statusEl.className = 'status-connected';
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log("Mensaje del servidor:", data);

                switch (data.type) {
                    case 'incoming_call': handleIncomingCall(data); break;
                    case 'offer_from_server': handleOfferFromServer(data); break;
                    case 'call_terminated': console.log("El servidor informa que la llamada ha terminado."); resetUI(); break;
                }
            };

            ws.onerror = (error) => {
                console.error("Error de WebSocket:", error);
                statusEl.textContent = 'Error: Conexión perdida con el servidor.';
                statusEl.className = 'status-disconnected';
            };

            ws.onclose = () => {
                console.warn("Conexión WebSocket cerrada. Intentando reconectar en 5 segundos...");
                statusEl.textContent = 'Estado: Desconectado. Reconectando...';
                statusEl.className = 'status-disconnected';
                setTimeout(connectWebSocket, 5000);
            };
        }

        function handleIncomingCall(data) {
            if (currentCallId) return;
            currentCallId = data.call_id;
            callerInfoEl.textContent = `Llamada entrante de: ${data.from}`;
            incomingCallAlertEl.style.display = 'block';
        }

        async function handleOfferFromServer(data) {
            console.log("Recibida oferta SDP del servidor, iniciando WebRTC.");
            
            browser_pc = new RTCPeerConnection();

            browser_pc.ontrack = (event) => {
                console.log("Recibida pista de audio remota.");
                if (remoteAudioEl.srcObject !== event.streams[0]) {
                    remoteAudioEl.srcObject = event.streams[0];
                    
                    // Forzamos la reproducción para evitar bloqueos de autoplay del navegador.
                    remoteAudioEl.play().catch(error => {
                        console.error("Error al intentar reproducir el audio automáticamente:", error);
                    });
                }
            };

            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                
                localStream.getTracks().forEach(track => {
                    console.log("Añadiendo pista de audio local (micrófono) a la conexión.");
                    browser_pc.addTrack(track, localStream);
                });

                await browser_pc.setRemoteDescription({ type: 'offer', sdp: data.sdp });
                const answer = await browser_pc.createAnswer();
                await browser_pc.setLocalDescription(answer);

                console.log("Enviando respuesta SDP del navegador al servidor.");
                ws.send(JSON.stringify({
                    type: 'answer_from_browser',
                    call_id: currentCallId,
                    sdp: browser_pc.localDescription.sdp
                }));

                inCallViewEl.style.display = 'block';

            } catch (error) {
                console.error("Error durante la negociación WebRTC:", error);
                resetUI();
            }
        }

        function answerCall() {
            if (currentCallId && ws.readyState === WebSocket.OPEN) {
                console.log(`Enviando solicitud para contestar la llamada: ${currentCallId}`);
                ws.send(JSON.stringify({ type: 'answer_call', call_id: currentCallId }));
                incomingCallAlertEl.style.display = 'none';
            }
        }

        function hangup() {
            if (currentCallId && ws.readyState === WebSocket.OPEN) {
                console.log(`Enviando solicitud para colgar la llamada: ${currentCallId}`);
                ws.send(JSON.stringify({ type: 'hangup_from_browser', call_id: currentCallId }));
            }
            resetUI();
        }

        function resetUI() {
            console.log("Reseteando la interfaz de usuario.");
            if (browser_pc) {
                browser_pc.close();
                browser_pc = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            remoteAudioEl.srcObject = null;
            currentCallId = null;
            incomingCallAlertEl.style.display = 'none';
            inCallViewEl.style.display = 'none';
        }

        answerButton.addEventListener('click', answerCall);
        hangupButton.addEventListener('click', hangup);

        connectWebSocket();
    </script>
</body>
</html>