<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel de Agente - Llamadas de WhatsApp</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background-color: #f0f2f5; color: #1c1e21; }
        .container { background-color: #fff; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); text-align: center; width: 90%; max-width: 400px; transition: all 0.3s ease; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        #status { font-size: 1rem; margin-bottom: 1.5rem; padding: 0.5rem; border-radius: 4px; transition: all 0.3s ease; }
        .status-connecting { color: #f5a623; background-color: #fffbe6; }
        .status-connected { color: #2e7d32; background-color: #e8f5e9; }
        .status-disconnected { color: #d32f2f; background-color: #ffebee; }
        .call-controls button { padding: 0.8rem 1.5rem; font-size: 1rem; border: none; border-radius: 6px; cursor: pointer; margin: 0 0.5rem; transition: background-color 0.2s; }
        .answer-btn { background-color: #42b72a; color: white; }
        .answer-btn:hover { background-color: #36a420; }
        .hangup-btn { background-color: #fa383e; color: white; }
        .hangup-btn:hover { background-color: #e02c32; }
        .mute-btn { background-color: #606770; color: white; }
        .mute-btn.muted { background-color: #31a24c; }
        .view { display: none; }
        #caller-info, #call-timer { font-weight: bold; margin-bottom: 1rem; font-size: 1.2rem; }
        audio { display: none; } /* El audio se reproduce, pero el control no es visible */
    </style>
</head>
<body>
    <div class="container">
        <h1>Panel de Llamadas</h1>
        <p id="status" class="status-connecting">Estado: Conectando al servidor...</p>

        <div id="idle-view" class="view">
            <p>Esperando llamadas...</p>
        </div>

        <div id="ringing-view" class="view">
            <p id="caller-info">Llamada entrante...</p>
            <div class="call-controls">
                <button id="answer-button" class="answer-btn">Contestar</button>
            </div>
        </div>

        <div id="active-call-view" class="view">
            <p id="call-timer">00:00</p>
            <audio id="remote-audio" autoplay playsinline></audio>
            <div class="call-controls">
                <button id="mute-button" class="mute-btn">Silenciar</button>
                <button id="hangup-button" class="hangup-btn">Colgar</button>
            </div>
        </div>
    </div>

    <script>
        // --- State Management ---
        let ws;
        let browser_pc;
        let localStream;
        let currentCallId = null;
        let timerInterval = null;
        let appState = 'IDLE';

        // --- DOM Elements ---
        const statusEl = document.getElementById('status');
        const idleView = document.getElementById('idle-view');
        const ringingView = document.getElementById('ringing-view');
        const activeCallView = document.getElementById('active-call-view');
        const callerInfoEl = document.getElementById('caller-info');
        const callTimerEl = document.getElementById('call-timer');
        const answerButton = document.getElementById('answer-button');
        const hangupButton = document.getElementById('hangup-button');
        const muteButton = document.getElementById('mute-button');
        const remoteAudioEl = document.getElementById('remote-audio');

        // --- UI Management ---
        function updateUI(newState) {
            appState = newState;
            console.log(`Cambiando estado a: ${appState}`);
            
            idleView.style.display = (appState === 'IDLE') ? 'block' : 'none';
            ringingView.style.display = (appState === 'RINGING') ? 'block' : 'none';
            activeCallView.style.display = (appState === 'ACTIVE' || appState === 'CONNECTING') ? 'block' : 'none';

            if (appState === 'CONNECTING') {
                callTimerEl.textContent = 'Conectando...';
            }
        }

        // --- WebSocket Logic ---
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            const wsUrl = `${protocol}//${host}/ws`;

            console.log(`Conectando al lobby en: ${wsUrl}`);
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log("Conectado al lobby.");
                statusEl.textContent = 'Estado: Listo para recibir llamadas';
                statusEl.className = 'status-connected';
                updateUI('IDLE');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log("Mensaje del servidor:", data);

                switch (data.type) {
                    case 'incoming_call': handleIncomingCall(data); break;
                    case 'offer_from_server': handleOfferFromServer(data); break;
                    case 'call_terminated': console.log("Llamada terminada por el servidor."); reset(); break;
                }
            };

            ws.onerror = (error) => console.error("Error de WebSocket:", error);
            ws.onclose = () => {
                console.warn("Conexión WebSocket cerrada. Reconectando...");
                statusEl.textContent = 'Estado: Desconectado. Reconectando...';
                statusEl.className = 'status-disconnected';
                setTimeout(connectWebSocket, 5000);
            };
        }

        // --- Call Handling Logic ---
        function handleIncomingCall(data) {
            if (appState !== 'IDLE') return;
            currentCallId = data.call_id;
            callerInfoEl.textContent = `Llamada entrante de: ${data.from}`;
            updateUI('RINGING');
        }

        async function handleOfferFromServer(data) {
            updateUI('CONNECTING');
            browser_pc = new RTCPeerConnection();

            browser_pc.oniceconnectionstatechange = () => {
                console.log(`Estado de conexión ICE: ${browser_pc.iceConnectionState}`);
                if (browser_pc.iceConnectionState === 'connected' || browser_pc.iceConnectionState === 'completed') {
                    if(appState !== 'ACTIVE') {
                        updateUI('ACTIVE');
                        startTimer();
                    }
                } else if (browser_pc.iceConnectionState === 'failed' || browser_pc.iceConnectionState === 'disconnected') {
                    reset();
                }
            };

            browser_pc.ontrack = (event) => {
                console.log("Recibida pista de audio remota (del llamante).");
                if (remoteAudioEl.srcObject !== event.streams[0]) {
                    remoteAudioEl.srcObject = event.streams[0];
                }
            };

            try {
                // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                // ESTA ES LA PARTE MÁS IMPORTANTE QUE SOLUCIONA EL PROBLEMA DE "NO MEDIA"
                // 1. Pedir acceso al micrófono. El navegador mostrará un popup de permisos.
                console.log("Solicitando acceso al micrófono...");
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                
                // 2. Una vez obtenido el permiso, añadir las pistas de audio del micrófono a la conexión.
                // Esto asegura que tu voz se envíe a través de WebRTC.
                localStream.getTracks().forEach(track => {
                    console.log("Añadiendo pista de audio local (micrófono) a la conexión.");
                    browser_pc.addTrack(track, localStream);
                });
                // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

                await browser_pc.setRemoteDescription({ type: 'offer', sdp: data.sdp });
                const answer = await browser_pc.createAnswer();
                await browser_pc.setLocalDescription(answer);

                console.log("Enviando respuesta SDP del navegador al servidor.");
                ws.send(JSON.stringify({
                    type: 'answer_from_browser',
                    call_id: currentCallId,
                    sdp: browser_pc.localDescription.sdp
                }));
            } catch (error) {
                console.error("Error durante la negociación WebRTC:", error);
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    alert("Necesitas permitir el acceso al micrófono para contestar llamadas.");
                }
                reset();
            }
        }

        function answerCall() {
            if (currentCallId && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'answer_call', call_id: currentCallId }));
                updateUI('CONNECTING');
            }
        }

        function hangup() {
            if (currentCallId && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'hangup_from_browser', call_id: currentCallId }));
            }
            reset();
        }

        function toggleMute() {
            if (!localStream) return;
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !track.enabled;
                muteButton.textContent = track.enabled ? 'Silenciar' : 'Reactivar';
                muteButton.classList.toggle('muted', !track.enabled);
            });
        }

        function startTimer() {
            let startTime = Date.now();
            stopTimer();
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const seconds = String(elapsed % 60).padStart(2, '0');
                callTimerEl.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function reset() {
            console.log("Reseteando estado de la llamada.");
            stopTimer();
            if (browser_pc) { browser_pc.close(); browser_pc = null; }
            if (localStream) { localStream.getTracks().forEach(track => track.stop()); localStream = null; }
            
            remoteAudioEl.srcObject = null;
            currentCallId = null;
            muteButton.textContent = 'Silenciar';
            muteButton.classList.remove('muted');
            
            updateUI('IDLE');
        }

        // --- Event Listeners ---
        answerButton.addEventListener('click', answerCall);
        hangupButton.addEventListener('click', hangup);
        muteButton.addEventListener('click', toggleMute);

        // --- Init ---
        connectWebSocket();
    </script>
</body>
</html>